---
title: "ARIMA"
author: "Юрченков Иван Александрович"
date: "15 04 2022"
mainfont: 'Noto Sans'
output: 
  pdf_document: 
    toc: yes
    fig_width: 8
    fig_height: 8
    fig_caption: yes
    number_sections: yes
    latex_engine: xelatex
    highlight: haddock
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## **Загрузка данных с yahoo.finance**


```{r}
library(quantmod)
```

```{r}
quantmod::getSymbols(Symbols = "AAPL")
```



```{r}
ts.df <- data.frame(get("AAPL"))
ts.df$Date <- as.Date.character(rownames(ts.df), format = "%Y-%m-%d")
ts.df$Num_Date <- as.numeric(ts.df$Date)
head(ts.df)
```


```{r}
sliding_window <- function(numeric_vector, window_elements = 10) {
  rows_matrix <- length(numeric_vector) - window_elements + 1
  cols_matrix <- window_elements
    
  result_matrix <- matrix(nrow = rows_matrix, ncol = cols_matrix)
  
  for (index in 1:rows_matrix) {
    result_matrix[index, ] <- numeric_vector[index:(index - 1 + window_elements)]   
  }
  
  return(result_matrix)
}
```


```{r}
l_norm <- function(numeric_vector, p = 2) {
    return( sum( abs(numeric_vector)^p )^(1/p) )
}


lin_reg <- function(X, y, 
                    l2_alpha = 0, 
                    batch_size = 0, 
                    shuffle = FALSE, 
                    alpha = 10e-3, 
                    max_iter = 10e4,
                    etol = 10e-02) {
    X <- cbind(1, as.matrix(X))
    y <- as.matrix(y)
    
    if (is.null(colnames(y))) {
        colnames(y) <- paste0("Y", 1:ncol(y))
    }
    
    if (is.null(colnames(X))) {
        colnames(X) <- c("bias", paste0("X", 1:(ncol(X)-1)))
    }
    
    if (batch_size == 0) {
      w <- pracma::inv(t(X) %*% X + l2_alpha * diag(1, nrow = ncol(X))) %*% t(X) %*% y      
    } else {
      w <- matrix(data = 1, 
                  ncol = ncol(y), 
                  nrow = ncol(X))
      colnames(w) <- colnames(y)
      rownames(w) <- colnames(X)
      
      copy_X = X
      for (iter in 1:max_iter) {
          for (out_index in 1:ncol(y)) {
              if (shuffle) {
                  rows_sample <- sample(x = 1:nrow(X), size = nrow(X), replace = FALSE)
                  copy_X[1:nrow(X), ] <- copy_X[rows_sample, ]
              }
              
              for (batch_index in 1:(nrow(copy_X) %/% batch_size)) {
                X_batch <- copy_X[((batch_index - 1) * batch_size + 1):(batch_index * batch_size), ]
                y_batch <- y[((batch_index - 1) * batch_size + 1):(batch_index * batch_size), out_index]
                w[, out_index] <- w[, out_index] - 
                  alpha * 1/batch_size * 
                  (t(apply(X_batch, 2, function(x) x / l_norm(x, p = 2))) %*% 
                       (X_batch %*% w[, out_index] - y_batch))
              }
          }
      }
      rm("copy_X")
    }
    
    
    
    fit <- X %*% w
    r2_coeffs <- numeric(ncol(y))
    mae_coeffs <- numeric(ncol(y))
    sd_coeffs <- numeric(ncol(y))
    
    for (index in 1:ncol(y)) {
        r2_coeffs[index] <- 1 - sum((fit[, index] - y[, index])^2) / sum((mean(y[, index]) - y[, index])^2)
        mae_coeffs[index] <- 1/nrow(y) * sum(abs(y[, index] - fit[, index]))
        sd_coeffs[index] <- sqrt(sum((fit[, index] - y[, index])^2) / nrow(y))
    }
    
    names(r2_coeffs) <- colnames(y)
    names(mae_coeffs) <- colnames(y)
    names(sd_coeffs) <- colnames(y)
    
    rownames(w)[1] <- "bias"
    
    return(list("parameters" = w, 
                "fiited values" = fit, 
                "R squared" = r2_coeffs, 
                "Mean absolute error" = mae_coeffs,
                "Standart deviations" = sd_coeffs))
}

```



```{r}
X <- mtcars[, c(1, 2, 4, 6)]
y <- mtcars[, c(3, 5)]
model_lm <- lin_reg(X, y, l2_alpha = 0, batch_size = 20, shuffle = FALSE, max_iter = 1000, alpha = 0.001)
model_lm_0 <- lin_reg(X, y, l2_alpha = 0, batch_size = 0, shuffle = FALSE, max_iter = 1000, alpha = 0.001)
```


```{r}
model_lm_0$parameters
```



```{r}
model_lm$parameters
```


# Авторегрессия на временной ряд


```{r}
X_arr <- sliding_window(log(ts.df$AAPL.Close), 50)
y_arr <- X_arr[, 46:50]
X_arr <- X_arr[, 1:45]

model_R <- lin_reg(X_arr, y_arr, batch_size = 0, l2_alpha = 0)
model_L <- lin_reg(X_arr, y_arr, batch_size = 0, l2_alpha = 10)

plot(y_arr[, 1], pch = 19, cex = I(0.5), 
     xlim = c(length(y_arr[, 1]) - 300, length(y_arr[, 1]) + 100),
     ylim = c(4.7, 5.2))
lines(model_R$`fiited values`[, 1], col = "blue")
lines(model_L$`fiited values`[, 1], col = "red")
```


```{r}
predict_linreg <- function(X_new, wheights) {
  
    if (is.vector(X_new) & is.vector(wheights)) {
      
        result <- sum(c(1, X_new) * wheights)
        
    } else if (is.matrix(X_new) & is.vector(wheights)) {
      
        result <- cbind(1, X_new) %*% matrix(wheights, ncol = 1) 
        
    } else if (is.vector(X_new) & is.matrix(wheights)) {
      
        result <- matrix(c(1, X_new), nrow = 1) %*% wheights
    
    } else if (is.matrix(X_new) & is.matrix(wheights)) {
      
        result <- cbind(1, X_new) %*% wheights
    
    } else {
      
        result <- cbind(1, as.matrix(X_new)) %*% as.matrix(wheights)
    
    }
  
    return(result)
  
}


predict_autoreg <- function(X_new, wheights, 
                            ticks_forward = 100,
                            method = c("last_forward", "grouped_forward")) {
    method <- method[1] 
    future <- numeric(ticks_forward)
    X_new <- X_new[(length(X_new) - ticks_forward + 1):length(X_new)]
    
    if (method == "grouped_forward") {
        
    } else {
        for (future_ticks in 1:ticks_forward) {
            future[future_ticks] <- as.vector(predict_linreg(X_new, wheights))[1]
            X_new <- c(X_new[-1], future[future_ticks])
        }
    }
    
    return(future)
}
```


